{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { gql } from '@apollo/client';\nimport * as Apollo from '@apollo/client';\nconst defaultOptions = {};\n/** All built-in and custom scalars, mapped to their actual values */\n\nexport let CacheControlScope;\n\n(function (CacheControlScope) {\n  CacheControlScope[\"Public\"] = \"PUBLIC\";\n  CacheControlScope[\"Private\"] = \"PRIVATE\";\n})(CacheControlScope || (CacheControlScope = {}));\n\nexport const CreateProductDocument = gql`\n    mutation createProduct($input: CreateProductInput!) {\n  createProduct(input: $input) {\n    id\n    price\n    attrs {\n      name\n      value\n    }\n  }\n}\n    `;\n\n/**\n * __useCreateProductMutation__\n *\n * To run a mutation, you first call `useCreateProductMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `useCreateProductMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [createProductMutation, { data, loading, error }] = useCreateProductMutation({\n *   variables: {\n *      input: // value for 'input'\n *   },\n * });\n */\nexport function useCreateProductMutation(baseOptions) {\n  const options = _objectSpread(_objectSpread({}, defaultOptions), baseOptions);\n\n  return Apollo.useMutation(CreateProductDocument, options);\n}\nexport const ProductsDocument = gql`\n    query products {\n  products {\n    id\n    price\n    attrs {\n      name\n      value\n    }\n    product {\n      name\n    }\n  }\n}\n    `;\n/**\n * __useProductsQuery__\n *\n * To run a query within a React component, call `useProductsQuery` and pass it any options that fit your needs.\n * When your component renders, `useProductsQuery` returns an object from Apollo Client that contains loading, error, and data properties\n * you can use to render your UI.\n *\n * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;\n *\n * @example\n * const { data, loading, error } = useProductsQuery({\n *   variables: {\n *   },\n * });\n */\n\nexport function useProductsQuery(baseOptions) {\n  const options = _objectSpread(_objectSpread({}, defaultOptions), baseOptions);\n\n  return Apollo.useQuery(ProductsDocument, options);\n}\nexport function useProductsLazyQuery(baseOptions) {\n  const options = _objectSpread(_objectSpread({}, defaultOptions), baseOptions);\n\n  return Apollo.useLazyQuery(ProductsDocument, options);\n}","map":{"version":3,"sources":["G:/New folder/frontend/src/generated/graphql.tsx"],"names":["gql","Apollo","defaultOptions","CacheControlScope","CreateProductDocument","useCreateProductMutation","baseOptions","options","useMutation","ProductsDocument","useProductsQuery","useQuery","useProductsLazyQuery","useLazyQuery"],"mappings":";;;;;;AAAA,SAASA,GAAT,QAAoB,gBAApB;AACA,OAAO,KAAKC,MAAZ,MAAwB,gBAAxB;AAKA,MAAMC,cAAc,GAAI,EAAxB;AACA;;AAuBA,WAAYC,iBAAZ;;WAAYA,iB;AAAAA,EAAAA,iB;AAAAA,EAAAA,iB;GAAAA,iB,KAAAA,iB;;AAoFZ,OAAO,MAAMC,qBAAqB,GAAGJ,GAAI;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAXO;;AAcP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASK,wBAAT,CAAkCC,WAAlC,EAAmI;AAClI,QAAMC,OAAO,mCAAOL,cAAP,GAA0BI,WAA1B,CAAb;;AACA,SAAOL,MAAM,CAACO,WAAP,CAA0EJ,qBAA1E,EAAiGG,OAAjG,CAAP;AACD;AAIP,OAAO,MAAME,gBAAgB,GAAGT,GAAI;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAdO;AAgBP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASU,gBAAT,CAA0BJ,WAA1B,EAAwG;AACvG,QAAMC,OAAO,mCAAOL,cAAP,GAA0BI,WAA1B,CAAb;;AACA,SAAOL,MAAM,CAACU,QAAP,CAAuDF,gBAAvD,EAAyEF,OAAzE,CAAP;AACD;AACP,OAAO,SAASK,oBAAT,CAA8BN,WAA9B,EAAgH;AAC7G,QAAMC,OAAO,mCAAOL,cAAP,GAA0BI,WAA1B,CAAb;;AACA,SAAOL,MAAM,CAACY,YAAP,CAA2DJ,gBAA3D,EAA6EF,OAA7E,CAAP;AACD","sourcesContent":["import { gql } from '@apollo/client';\nimport * as Apollo from '@apollo/client';\nexport type Maybe<T> = T | null;\nexport type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };\nexport type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };\nexport type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };\nconst defaultOptions =  {}\n/** All built-in and custom scalars, mapped to their actual values */\nexport type Scalars = {\n  ID: string;\n  String: string;\n  Boolean: boolean;\n  Int: number;\n  Float: number;\n  /** The `Upload` scalar type represents a file upload. */\n  Upload: any;\n};\n\n\nexport type AttrsInput = {\n  name: Scalars['String'];\n  value: Scalars['String'];\n};\n\nexport type AttrsProduct = {\n  __typename?: 'AttrsProduct';\n  name: Scalars['String'];\n  value: Scalars['String'];\n};\n\nexport enum CacheControlScope {\n  Public = 'PUBLIC',\n  Private = 'PRIVATE'\n}\n\nexport type CreateProductInput = {\n  products: ProductInput;\n  attrs: Array<AttrsInput>;\n  price: Scalars['Int'];\n};\n\nexport type Mutation = {\n  __typename?: 'Mutation';\n  createProduct: ProductVariant;\n};\n\n\nexport type MutationCreateProductArgs = {\n  input: CreateProductInput;\n};\n\nexport type Product = {\n  __typename?: 'Product';\n  id: Scalars['ID'];\n  name: Scalars['String'];\n  slug?: Maybe<Scalars['String']>;\n  description: Scalars['String'];\n};\n\nexport type ProductInput = {\n  name: Scalars['String'];\n  description: Scalars['String'];\n};\n\nexport type ProductVariant = {\n  __typename?: 'ProductVariant';\n  id: Scalars['ID'];\n  product: Product;\n  price: Scalars['Int'];\n  attrs?: Maybe<Array<Maybe<AttrsProduct>>>;\n};\n\nexport type Query = {\n  __typename?: 'Query';\n  products?: Maybe<Array<Maybe<ProductVariant>>>;\n};\n\n\nexport type CreateProductMutationVariables = Exact<{\n  input: CreateProductInput;\n}>;\n\n\nexport type CreateProductMutation = (\n  { __typename?: 'Mutation' }\n  & { createProduct: (\n    { __typename?: 'ProductVariant' }\n    & Pick<ProductVariant, 'id' | 'price'>\n    & { attrs?: Maybe<Array<Maybe<(\n      { __typename?: 'AttrsProduct' }\n      & Pick<AttrsProduct, 'name' | 'value'>\n    )>>> }\n  ) }\n);\n\nexport type ProductsQueryVariables = Exact<{ [key: string]: never; }>;\n\n\nexport type ProductsQuery = (\n  { __typename?: 'Query' }\n  & { products?: Maybe<Array<Maybe<(\n    { __typename?: 'ProductVariant' }\n    & Pick<ProductVariant, 'id' | 'price'>\n    & { attrs?: Maybe<Array<Maybe<(\n      { __typename?: 'AttrsProduct' }\n      & Pick<AttrsProduct, 'name' | 'value'>\n    )>>>, product: (\n      { __typename?: 'Product' }\n      & Pick<Product, 'name'>\n    ) }\n  )>>> }\n);\n\n\nexport const CreateProductDocument = gql`\n    mutation createProduct($input: CreateProductInput!) {\n  createProduct(input: $input) {\n    id\n    price\n    attrs {\n      name\n      value\n    }\n  }\n}\n    `;\nexport type CreateProductMutationFn = Apollo.MutationFunction<CreateProductMutation, CreateProductMutationVariables>;\n\n/**\n * __useCreateProductMutation__\n *\n * To run a mutation, you first call `useCreateProductMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `useCreateProductMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [createProductMutation, { data, loading, error }] = useCreateProductMutation({\n *   variables: {\n *      input: // value for 'input'\n *   },\n * });\n */\nexport function useCreateProductMutation(baseOptions?: Apollo.MutationHookOptions<CreateProductMutation, CreateProductMutationVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useMutation<CreateProductMutation, CreateProductMutationVariables>(CreateProductDocument, options);\n      }\nexport type CreateProductMutationHookResult = ReturnType<typeof useCreateProductMutation>;\nexport type CreateProductMutationResult = Apollo.MutationResult<CreateProductMutation>;\nexport type CreateProductMutationOptions = Apollo.BaseMutationOptions<CreateProductMutation, CreateProductMutationVariables>;\nexport const ProductsDocument = gql`\n    query products {\n  products {\n    id\n    price\n    attrs {\n      name\n      value\n    }\n    product {\n      name\n    }\n  }\n}\n    `;\n\n/**\n * __useProductsQuery__\n *\n * To run a query within a React component, call `useProductsQuery` and pass it any options that fit your needs.\n * When your component renders, `useProductsQuery` returns an object from Apollo Client that contains loading, error, and data properties\n * you can use to render your UI.\n *\n * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;\n *\n * @example\n * const { data, loading, error } = useProductsQuery({\n *   variables: {\n *   },\n * });\n */\nexport function useProductsQuery(baseOptions?: Apollo.QueryHookOptions<ProductsQuery, ProductsQueryVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useQuery<ProductsQuery, ProductsQueryVariables>(ProductsDocument, options);\n      }\nexport function useProductsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ProductsQuery, ProductsQueryVariables>) {\n          const options = {...defaultOptions, ...baseOptions}\n          return Apollo.useLazyQuery<ProductsQuery, ProductsQueryVariables>(ProductsDocument, options);\n        }\nexport type ProductsQueryHookResult = ReturnType<typeof useProductsQuery>;\nexport type ProductsLazyQueryHookResult = ReturnType<typeof useProductsLazyQuery>;\nexport type ProductsQueryResult = Apollo.QueryResult<ProductsQuery, ProductsQueryVariables>;"]},"metadata":{},"sourceType":"module"}